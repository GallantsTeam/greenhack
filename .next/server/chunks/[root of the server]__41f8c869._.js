module.exports = {

"[project]/.next-internal/server/app/api/admin/site-settings/telegram/test-message/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route.runtime.dev.js [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/timers [external] (timers, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/mysql.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* __next_internal_action_entry_do_not_use__ {"6058d2186d06199210990ee590d0261587c858a217":"query"} */ __turbopack_context__.s({
    "query": (()=>query)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$server$2d$reference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$app$2d$render$2f$encryption$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/app-render/encryption.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js [app-route] (ecmascript)");
;
;
;
const connectionConfig = {
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 10,
    namedPlaceholders: true
};
let pool = null;
function getPool() {
    if (!pool) {
        if (!process.env.DB_HOST || !process.env.DB_USER || !process.env.DB_NAME) {
            console.error("Database environment variables DB_HOST, DB_USER, or DB_NAME are not set.");
            throw new Error("Database environment variables are not fully set. Please check your .env.local file.");
        }
        try {
            pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool(connectionConfig);
            console.log("MySQL connection pool created successfully.");
            // Test the pool by getting a connection (optional, but good for early feedback)
            pool.getConnection().then((connection)=>{
                console.log("Successfully connected to database via pool.");
                connection.release();
            }).catch((err)=>{
                console.error("Failed to get a connection from pool on startup:", err);
            // Depending on severity, you might want to invalidate the pool or exit
            // For now, we'll let further queries fail if the pool is truly unusable.
            });
        } catch (error) {
            console.error("Failed to create MySQL connection pool:", error);
            // Ensure pool remains null if creation fails
            pool = null;
            throw new Error("Database connection pool could not be created.");
        }
    }
    return pool;
}
async function /*#__TURBOPACK_DISABLE_EXPORT_MERGING__*/ query(sql, params) {
    const currentPool = getPool(); // This will throw if pool cannot be initialized
    let connection;
    try {
        connection = await currentPool.getConnection();
        console.log(`Executing SQL: ${sql} with params: ${params ? JSON.stringify(params) : 'No params'}`);
        const [results] = await connection.execute(sql, params);
        return results;
    } catch (error) {
        console.error('Database query error:', error.message, error.code, error.sqlMessage, error.sql);
        throw new Error(`Database query failed: ${error.message}`);
    } finally{
        if (connection) {
            connection.release();
        }
    }
}
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ensureServerEntryExports"])([
    query
]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$server$2d$reference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerServerReference"])(query, "6058d2186d06199210990ee590d0261587c858a217", null);
}}),
"[project]/src/lib/telegram.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/telegram.ts
__turbopack_context__.s({
    "notifyAdminOnAdminLogin": (()=>notifyAdminOnAdminLogin),
    "notifyAdminOnBalanceDeposit": (()=>notifyAdminOnBalanceDeposit),
    "notifyAdminOnProductPurchase": (()=>notifyAdminOnProductPurchase),
    "notifyAdminOnPromoCodeCreation": (()=>notifyAdminOnPromoCodeCreation),
    "sendKeyActivationRequestToAdmin": (()=>sendKeyActivationRequestToAdmin),
    "sendTelegramMessage": (()=>sendTelegramMessage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mysql.ts [app-route] (ecmascript)");
;
const SETTINGS_ROW_ID = 1; // Assuming settings are in a single row with id=1
async function getTelegramSettingsFromDb() {
    console.log("[TelegramLib][getTelegramSettingsFromDb] Fetching Telegram configuration from DB...");
    try {
        const [tgSettingsResults, adminPrefsResults, siteNotificationSettingsResults] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_telegram_settings WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ]),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM admin_telegram_notification_prefs WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ]),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_notification_settings WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ])
        ]);
        const telegramSettings = Array.isArray(tgSettingsResults) && tgSettingsResults.length > 0 ? tgSettingsResults[0] : null;
        const adminPrefsDb = Array.isArray(adminPrefsResults) && adminPrefsResults.length > 0 ? adminPrefsResults[0] : null;
        const notificationPrefs = adminPrefsDb ? {
            id: adminPrefsDb.id,
            notify_admin_on_balance_deposit: Boolean(adminPrefsDb.notify_admin_on_balance_deposit),
            notify_admin_on_product_purchase: Boolean(adminPrefsDb.notify_admin_on_product_purchase),
            notify_admin_on_promo_code_creation: Boolean(adminPrefsDb.notify_admin_on_promo_code_creation),
            notify_admin_on_admin_login: Boolean(adminPrefsDb.notify_admin_on_admin_login),
            notify_admin_on_key_activation_request: adminPrefsDb.notify_admin_on_key_activation_request === undefined ? true : Boolean(adminPrefsDb.notify_admin_on_key_activation_request),
            updated_at: adminPrefsDb.updated_at
        } : null;
        const siteNotificationSettingsDb = Array.isArray(siteNotificationSettingsResults) && siteNotificationSettingsResults.length > 0 ? siteNotificationSettingsResults[0] : null;
        const siteNotificationSettings = siteNotificationSettingsDb ? {
            id: siteNotificationSettingsDb.id || SETTINGS_ROW_ID,
            notify_on_registration: Boolean(siteNotificationSettingsDb.notify_on_registration),
            notify_on_balance_deposit: Boolean(siteNotificationSettingsDb.notify_on_balance_deposit),
            notify_on_product_purchase: Boolean(siteNotificationSettingsDb.notify_on_product_purchase),
            notify_on_support_reply: Boolean(siteNotificationSettingsDb.notify_on_support_reply),
            notify_on_software_activation: Boolean(siteNotificationSettingsDb.notify_on_software_activation),
            notify_on_license_expiry_soon: Boolean(siteNotificationSettingsDb.notify_on_license_expiry_soon),
            notify_on_promotions: Boolean(siteNotificationSettingsDb.notify_on_promotions),
            updated_at: siteNotificationSettingsDb.updated_at
        } : null;
        console.log("[TelegramLib][getTelegramSettingsFromDb] Fetched Telegram Settings (tokens hidden):", telegramSettings ? {
            ...telegramSettings,
            client_bot_token: '***',
            admin_bot_token: '***',
            key_bot_token: '***'
        } : null);
        console.log("[TelegramLib][getTelegramSettingsFromDb] Fetched Admin Notification Prefs:", notificationPrefs);
        console.log("[TelegramLib][getTelegramSettingsFromDb] Fetched Site Notification Settings:", siteNotificationSettings);
        return {
            telegramSettings,
            notificationPrefs,
            siteNotificationSettings
        };
    } catch (error) {
        console.error("[TelegramLib][getTelegramSettingsFromDb] Error fetching Telegram configuration:", error);
        return {
            telegramSettings: null,
            notificationPrefs: null,
            siteNotificationSettings: null
        };
    }
}
async function sendTelegramMessage(botToken, chatId, message, parseMode = 'MarkdownV2', replyMarkup// For inline keyboards
) {
    if (!botToken || !chatId || !message) {
        const errorMsg = "[TelegramLib] Send Error: Missing botToken, chatId, or message for Telegram.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
    console.log(`[TelegramLib] Attempting to send message to ${chatId} via URL: ${telegramApiUrl.replace(botToken, '***TOKEN***')}`);
    const bodyPayload = {
        chat_id: chatId,
        text: message,
        parse_mode: parseMode
    };
    if (replyMarkup) {
        bodyPayload.reply_markup = replyMarkup;
    }
    try {
        const response = await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(bodyPayload)
        });
        const data = await response.json();
        console.log(`[TelegramLib] Response from Telegram API for chat_id ${chatId}:`, JSON.stringify(data, null, 2));
        if (data.ok) {
            console.log(`[TelegramLib] Message sent successfully to chat_id ${chatId}.`);
            return {
                success: true,
                message: `Message sent to ${chatId}`
            };
        } else {
            console.error('[TelegramLib] Telegram API Error:', data);
            return {
                success: false,
                message: `Telegram API Error: ${data.description}`,
                error: data
            };
        }
    } catch (error) {
        console.error('[TelegramLib] Error sending Telegram message via fetch:', error);
        return {
            success: false,
            message: `Network or parsing error: ${error.message}`,
            error
        };
    }
}
function escapeTelegramMarkdownV2(text) {
    if (text === null || text === undefined) return '';
    const textStr = String(text);
    const escapeChars = [
        '_',
        '*',
        '[',
        ']',
        '(',
        ')',
        '~',
        '`',
        '>',
        '#',
        '+',
        '-',
        '=',
        '|',
        '{',
        '}',
        '.',
        '!'
    ];
    return textStr.split('').map((char)=>escapeChars.includes(char) ? `\\${char}` : char).join('');
}
async function notifyAdminOnBalanceDeposit(userId, username, amountGh, reason) {
    console.log(`[TelegramLib] notifyAdminOnBalanceDeposit called for user: ${username} (ID: ${userId}), amount: ${amountGh}, reason: ${reason}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token) {
        console.log("[TelegramLib] notifyAdminOnBalanceDeposit check failed: Admin bot token not configured.");
        return;
    }
    if (!telegramSettings.admin_bot_chat_ids) {
        console.log("[TelegramLib] notifyAdminOnBalanceDeposit check failed: Admin bot chat IDs not configured.");
        return;
    }
    if (!notificationPrefs?.notify_admin_on_balance_deposit) {
        console.log("[TelegramLib] notifyAdminOnBalanceDeposit check failed: Notification type is disabled in settings.");
        return;
    }
    const reasonText = reason ? `\nПричина: \`${escapeTelegramMarkdownV2(reason)}\`` : '';
    const message = `💰 *Пополнение баланса*
Пользователь: \`${escapeTelegramMarkdownV2(username)}\` (ID: \`${userId}\`)
Сумма: \`+${escapeTelegramMarkdownV2(amountGh.toFixed(2))}\` GH${reasonText}`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    console.log(`[TelegramLib] Prepared balance deposit notification. Admin chat IDs: ${chatIds.join(', ')}`);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib] Attempting to send balance deposit notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib] Failed to send balance deposit notification to ${chatId}:`, result.message, result.error);
            }
        } catch (e) {
            console.error(`[TelegramLib] CRITICAL ERROR sending balance deposit notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnProductPurchase(userId, username, productName, durationDays, amountGh) {
    console.log(`[TelegramLib] notifyAdminOnProductPurchase called for user: ${username}, product: ${productName}, amount: ${amountGh}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_product_purchase) {
        console.log("[TelegramLib] notifyAdminOnProductPurchase check failed: Bot token, chat IDs, or setting disabled.");
        return;
    }
    const durationText = durationDays ? ` (${escapeTelegramMarkdownV2(durationDays)} дн\\.)` : '';
    const message = `🛍️ *Новая покупка товара*
Пользователь: \`${escapeTelegramMarkdownV2(username)}\` (ID: \`${userId}\`)
Товар: \`${escapeTelegramMarkdownV2(productName)}\`${durationText}
Сумма: \`${escapeTelegramMarkdownV2(amountGh.toFixed(2))}\` GH`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    console.log(`[TelegramLib] Prepared product purchase notification. Admin chat IDs: ${chatIds.join(', ')}`);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib] Attempting to send product purchase notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib] Failed to send product purchase notification to ${chatId}:`, result.message, result.error);
            }
        } catch (e) {
            console.error(`[TelegramLib] CRITICAL ERROR sending product purchase notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnPromoCodeCreation(adminUsername, promoCode) {
    console.log(`[TelegramLib] notifyAdminOnPromoCodeCreation called for code: ${promoCode.code}, created by: ${adminUsername || 'System'}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_promo_code_creation) {
        console.log("[TelegramLib] notifyAdminOnPromoCodeCreation check failed: Bot token, chat IDs, or setting disabled.");
        return;
    }
    let rewardText = '';
    if (promoCode.type === 'balance_gh' && promoCode.value_gh) {
        rewardText = `Баланс: \`${escapeTelegramMarkdownV2(promoCode.value_gh.toFixed(2))}\` GH`;
    } else if (promoCode.type === 'product' && promoCode.product_name) {
        const duration = promoCode.duration_days ? ` (${escapeTelegramMarkdownV2(promoCode.duration_days)} дн\\.)` : '';
        const mode = promoCode.mode_label ? ` [${escapeTelegramMarkdownV2(promoCode.mode_label)}]` : '';
        rewardText = `Товар: \`${escapeTelegramMarkdownV2(promoCode.product_name)}\`${duration}${mode}`;
    }
    const message = `🎁 *Создан новый промокод*
Код: \`${escapeTelegramMarkdownV2(promoCode.code)}\`
Тип: \`${escapeTelegramMarkdownV2(promoCode.type)}\`
Награда: ${rewardText}
Макс\\. использований: \`${promoCode.max_uses}\`
Истекает: \`${promoCode.expires_at ? escapeTelegramMarkdownV2(new Date(promoCode.expires_at).toLocaleString('ru-RU')) : 'Бессрочно'}\`
${adminUsername ? `Создал: \`${escapeTelegramMarkdownV2(adminUsername)}\`` : 'Создан системой'}`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    console.log(`[TelegramLib] Prepared promo code creation notification. Admin chat IDs: ${chatIds.join(', ')}`);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib] Attempting to send promo code creation notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib] Failed to send promo code creation notification to ${chatId}:`, result.message, result.error);
            }
        } catch (e) {
            console.error(`[TelegramLib] CRITICAL ERROR sending promo code creation notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnAdminLogin(adminUsername, ipAddress) {
    console.log(`[TelegramLib] notifyAdminOnAdminLogin called for admin: ${adminUsername}, IP: ${ipAddress}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_admin_login) {
        console.log("[TelegramLib] notifyAdminOnAdminLogin check failed: Bot token, chat IDs, or setting disabled.");
        return;
    }
    const ipText = ipAddress ? `IP: \`${escapeTelegramMarkdownV2(ipAddress)}\`` : 'IP не определен';
    const message = `🛡️ *Вход в Админ-панель*
Пользователь: \`${escapeTelegramMarkdownV2(adminUsername)}\`
${ipText}
Время: \`${escapeTelegramMarkdownV2(new Date().toLocaleString('ru-RU'))}\``;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    console.log(`[TelegramLib] Prepared admin login notification. Admin chat IDs: ${chatIds.join(', ')}`);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib] Attempting to send admin login notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib] Failed to send admin login notification to ${chatId}:`, result.message, result.error);
            }
        } catch (e) {
            console.error(`[TelegramLib] CRITICAL ERROR sending admin login notification to ${chatId}:`, e);
        }
    }
}
async function sendKeyActivationRequestToAdmin(item, user) {
    console.log(`[TelegramLib] sendKeyActivationRequestToAdmin called for item ID: ${item.id}, user: ${user.username}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    const keyBotToken = telegramSettings?.key_bot_token;
    const adminChatIdsString = telegramSettings?.key_bot_admin_chat_ids;
    if (!keyBotToken) {
        const errorMsg = "[TelegramLib] Key Bot token not configured in site_telegram_settings.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    if (!adminChatIdsString) {
        const errorMsg = "[TelegramLib] Key Bot admin chat IDs not configured in site_telegram_settings.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    if (!notificationPrefs?.notify_admin_on_key_activation_request) {
        const logMsg = "[TelegramLib] sendKeyActivationRequestToAdmin check failed: Notification type 'notify_admin_on_key_activation_request' is disabled.";
        console.log(logMsg);
        return {
            success: true,
            message: "Key activation request notification type disabled."
        };
    }
    const productName = item.product_name || 'Неизвестный товар';
    const duration = item.duration_days ? ` (${item.duration_days} дн.)` : '';
    const mode = item.mode_label ? ` [${item.mode_label}]` : '';
    const userKey = item.activation_code || 'Ключ не указан';
    const message = `🔑 *Запрос на активацию ключа*
Пользователь: \`${escapeTelegramMarkdownV2(user.username)}\` (ID: \`${user.id}\`)
Товар: \`${escapeTelegramMarkdownV2(productName)}${escapeTelegramMarkdownV2(duration)}${escapeTelegramMarkdownV2(mode)}\`
Инвентарь ID: \`${item.id}\`
Предоставленный ключ: \`${escapeTelegramMarkdownV2(userKey)}\``;
    const inline_keyboard = [
        [
            {
                text: '✅ Активировать',
                callback_data: `activate_key:${item.id}`
            },
            {
                text: '❌ Отклонить',
                callback_data: `reject_key:${item.id}`
            }
        ]
    ];
    const chatIds = adminChatIdsString.split(',').map((id)=>id.trim()).filter((id)=>id);
    let allSentSuccessfully = true;
    let firstErrorResult = null;
    console.log(`[TelegramLib] Prepared key activation request notification. Key Bot Admin chat IDs: ${chatIds.join(', ')}`);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib] Attempting to send key activation request to admin chat ID: ${chatId} using Key Bot`);
            const result = await sendTelegramMessage(keyBotToken, chatId, message, 'MarkdownV2', {
                inline_keyboard
            });
            if (!result.success) {
                allSentSuccessfully = false;
                if (!firstErrorResult) {
                    firstErrorResult = result;
                }
                console.error(`[TelegramLib] Failed to send key activation request to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib] Key activation request sent successfully to ${chatId}.`);
            }
        } catch (e) {
            allSentSuccessfully = false;
            if (!firstErrorResult) {
                firstErrorResult = {
                    success: false,
                    message: `Network or parsing error for key activation: ${e.message}`,
                    error: e
                };
            }
            console.error(`[TelegramLib] CRITICAL ERROR sending key activation request to ${chatId}:`, e);
        }
    }
    return allSentSuccessfully ? {
        success: true,
        message: "Уведомление администратору отправлено."
    } : firstErrorResult || {
        success: false,
        message: "Неизвестная ошибка при отправке уведомлений администратору."
    };
}
}}),
"[project]/src/app/api/admin/site-settings/telegram/test-message/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/app/api/admin/site-settings/telegram/test-message/route.ts
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mysql.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/telegram.ts [app-route] (ecmascript)");
;
;
;
const SETTINGS_ROW_ID = 1;
async function POST(request) {
    try {
        // TODO: Add proper admin authentication check here
        const { botType, message } = await request.json();
        if (!botType || !message || ![
            'client',
            'admin',
            'key'
        ].includes(botType)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: 'Некорректный тип бота или отсутствует сообщение.'
            }, {
                status: 400
            });
        }
        const settingsResults = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_telegram_settings WHERE id = ? LIMIT 1', [
            SETTINGS_ROW_ID
        ]);
        if (!Array.isArray(settingsResults) || settingsResults.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: 'Настройки Telegram не найдены.'
            }, {
                status: 404
            });
        }
        const config = settingsResults[0];
        let token;
        let chatIdInput;
        switch(botType){
            case 'client':
                token = config.client_bot_token;
                chatIdInput = config.client_bot_chat_id;
                break;
            case 'admin':
                token = config.admin_bot_token;
                chatIdInput = config.admin_bot_chat_ids;
                break;
            case 'key':
                token = config.key_bot_token;
                chatIdInput = config.key_bot_admin_chat_ids;
                break;
            default:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    message: 'Неизвестный тип бота.'
                }, {
                    status: 400
                });
        }
        if (!token) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: `Токен для ${botType} бота не настроен.`
            }, {
                status: 400
            });
        }
        if (!chatIdInput) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: `ID чата(ов) для ${botType} бота не настроен.`
            }, {
                status: 400
            });
        }
        const chatIds = chatIdInput.split(',').map((id)=>id.trim()).filter((id)=>id);
        if (chatIds.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: `Не указаны корректные ID чата(ов) для ${botType} бота.`
            }, {
                status: 400
            });
        }
        let allSentSuccessfully = true;
        let firstErrorResult = null;
        for (const chatId of chatIds){
            const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendTelegramMessage"])(token, chatId, message);
            if (!result.success) {
                allSentSuccessfully = false;
                if (!firstErrorResult) firstErrorResult = result;
                console.error(`Failed to send test message to ${chatId} for ${botType} bot:`, result.error);
            }
        }
        if (allSentSuccessfully) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: `Тестовое сообщение успешно отправлено на ${chatIds.join(', ')} через ${botType} бота.`
            });
        } else {
            const errorMessageDetail = firstErrorResult?.message || firstErrorResult?.error?.description || 'Неизвестная ошибка отправки.';
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: `Не удалось отправить тестовое сообщение на один или несколько чатов. Первая ошибка: ${errorMessageDetail}`
            }, {
                status: 500
            });
        }
    } catch (error) {
        console.error('API Send Test Telegram Error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: `Внутренняя ошибка сервера: ${error.message}`
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__41f8c869._.js.map