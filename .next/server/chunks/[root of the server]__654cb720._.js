module.exports = {

"[project]/.next-internal/server/app/api/admin/key-activation-requests/[inventoryItemId]/approve/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route.runtime.dev.js [external] (next/dist/compiled/next-server/app-route.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page.runtime.dev.js [external] (next/dist/compiled/next-server/app-page.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/timers [external] (timers, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/src/lib/mysql.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* __next_internal_action_entry_do_not_use__ {"6058d2186d06199210990ee590d0261587c858a217":"query"} */ __turbopack_context__.s({
    "query": (()=>query)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$server$2d$reference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$app$2d$render$2f$encryption$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/app-render/encryption.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js [app-route] (ecmascript)");
;
;
;
const connectionConfig = {
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 10,
    namedPlaceholders: true
};
let pool = null;
function getPool() {
    if (!pool) {
        if (!process.env.DB_HOST || !process.env.DB_USER || !process.env.DB_NAME) {
            console.error("Database environment variables DB_HOST, DB_USER, or DB_NAME are not set.");
            throw new Error("Database environment variables are not fully set. Please check your .env.local file.");
        }
        try {
            pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool(connectionConfig);
            console.log("MySQL connection pool created successfully.");
            // Test the pool by getting a connection (optional, but good for early feedback)
            pool.getConnection().then((connection)=>{
                console.log("Successfully connected to database via pool.");
                connection.release();
            }).catch((err)=>{
                console.error("Failed to get a connection from pool on startup:", err);
            // Depending on severity, you might want to invalidate the pool or exit
            // For now, we'll let further queries fail if the pool is truly unusable.
            });
        } catch (error) {
            console.error("Failed to create MySQL connection pool:", error);
            // Ensure pool remains null if creation fails
            pool = null;
            throw new Error("Database connection pool could not be created.");
        }
    }
    return pool;
}
async function /*#__TURBOPACK_DISABLE_EXPORT_MERGING__*/ query(sql, params) {
    const currentPool = getPool(); // This will throw if pool cannot be initialized
    let connection;
    try {
        connection = await currentPool.getConnection();
        console.log(`Executing SQL: ${sql} with params: ${params ? JSON.stringify(params) : 'No params'}`);
        const [results] = await connection.execute(sql, params);
        return results;
    } catch (error) {
        console.error('Database query error:', error.message, error.code, error.sqlMessage, error.sql);
        throw new Error(`Database query failed: ${error.message}`);
    } finally{
        if (connection) {
            connection.release();
        }
    }
}
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$action$2d$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ensureServerEntryExports"])([
    query
]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$webpack$2f$loaders$2f$next$2d$flight$2d$loader$2f$server$2d$reference$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerServerReference"])(query, "6058d2186d06199210990ee590d0261587c858a217", null);
}}),
"[project]/src/lib/telegram.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/lib/telegram.ts
__turbopack_context__.s({
    "getTelegramSettingsFromDb": (()=>getTelegramSettingsFromDb),
    "notifyAdminOnAdminLogin": (()=>notifyAdminOnAdminLogin),
    "notifyAdminOnBalanceDeposit": (()=>notifyAdminOnBalanceDeposit),
    "notifyAdminOnProductPurchase": (()=>notifyAdminOnProductPurchase),
    "notifyAdminOnPromoCodeCreation": (()=>notifyAdminOnPromoCodeCreation),
    "sendKeyActivationRequestToAdmin": (()=>sendKeyActivationRequestToAdmin),
    "sendTelegramMessage": (()=>sendTelegramMessage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mysql.ts [app-route] (ecmascript)");
;
const SETTINGS_ROW_ID = 1; // Assuming settings are in a single row with id=1
async function getTelegramSettingsFromDb() {
    // console.log("[TelegramLib][getTelegramSettingsFromDb] Fetching Telegram configuration from DB...");
    try {
        const [tgSettingsResults, adminPrefsResults, siteNotificationSettingsResults] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_telegram_settings WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ]),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM admin_telegram_notification_prefs WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ]),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_notification_settings WHERE id = ? LIMIT 1', [
                SETTINGS_ROW_ID
            ])
        ]);
        const telegramSettings = Array.isArray(tgSettingsResults) && tgSettingsResults.length > 0 ? tgSettingsResults[0] : null;
        const adminPrefsDb = Array.isArray(adminPrefsResults) && adminPrefsResults.length > 0 ? adminPrefsResults[0] : null;
        const notificationPrefs = adminPrefsDb ? {
            id: adminPrefsDb.id,
            notify_admin_on_balance_deposit: Boolean(adminPrefsDb.notify_admin_on_balance_deposit),
            notify_admin_on_product_purchase: Boolean(adminPrefsDb.notify_admin_on_product_purchase),
            notify_admin_on_promo_code_creation: Boolean(adminPrefsDb.notify_admin_on_promo_code_creation),
            notify_admin_on_admin_login: Boolean(adminPrefsDb.notify_admin_on_admin_login),
            notify_admin_on_key_activation_request: adminPrefsDb.notify_admin_on_key_activation_request === undefined ? true : Boolean(adminPrefsDb.notify_admin_on_key_activation_request),
            updated_at: adminPrefsDb.updated_at
        } : null;
        const siteNotificationSettingsDb = Array.isArray(siteNotificationSettingsResults) && siteNotificationSettingsResults.length > 0 ? siteNotificationSettingsResults[0] : null;
        const siteNotificationSettings = siteNotificationSettingsDb ? {
            id: siteNotificationSettingsDb.id || SETTINGS_ROW_ID,
            notify_on_registration: Boolean(siteNotificationSettingsDb.notify_on_registration),
            notify_on_balance_deposit: Boolean(siteNotificationSettingsDb.notify_on_balance_deposit),
            notify_on_product_purchase: Boolean(siteNotificationSettingsDb.notify_on_product_purchase),
            notify_on_support_reply: Boolean(siteNotificationSettingsDb.notify_on_support_reply),
            notify_on_software_activation: Boolean(siteNotificationSettingsDb.notify_on_software_activation),
            notify_on_license_expiry_soon: Boolean(siteNotificationSettingsDb.notify_on_license_expiry_soon),
            notify_on_promotions: Boolean(siteNotificationSettingsDb.notify_on_promotions),
            updated_at: siteNotificationSettingsDb.updated_at
        } : null;
        return {
            telegramSettings,
            notificationPrefs,
            siteNotificationSettings
        };
    } catch (error) {
        console.error("[TelegramLib][getTelegramSettingsFromDb] Error fetching Telegram configuration:", error);
        return {
            telegramSettings: null,
            notificationPrefs: null,
            siteNotificationSettings: null
        };
    }
}
async function sendTelegramMessage(botToken, chatId, message, parseMode = 'MarkdownV2', replyMarkup) {
    // console.log(`[TelegramLib] sendTelegramMessage called. Token (start): ${botToken ? botToken.substring(0,10) + '...' : 'N/A'}, ChatID: ${chatId}, Message (start): "${message.substring(0,30)}...", ParseMode: ${parseMode}`);
    if (!botToken || !chatId || !message) {
        const errorMsg = "[TelegramLib] Send Error: Missing botToken, chatId, or message for Telegram.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
    const bodyPayload = {
        chat_id: chatId,
        text: message,
        parse_mode: parseMode
    };
    if (replyMarkup) {
        bodyPayload.reply_markup = replyMarkup;
    }
    // console.log(`[TelegramLib] Preparing to send. Final chat_id type: ${typeof bodyPayload.chat_id}, value: '${bodyPayload.chat_id}'`);
    // console.log(`[TelegramLib] EXACT PAYLOAD TO TELEGRAM (token details excluded):`, JSON.stringify({ ...bodyPayload, bot_token_info: `Token ending with ...${botToken.slice(-6)}` }, null, 2));
    try {
        const response = await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(bodyPayload)
        });
        const data = await response.json();
        // console.log(`[TelegramLib] Telegram API response status: ${response.status}, ok: ${response.ok}`);
        // console.log('[TelegramLib] Telegram API response data:', JSON.stringify(data, null, 2));
        if (data.ok) {
            // console.log(`[TelegramLib] Message sent successfully to chat_id ${chatId}.`);
            return {
                success: true,
                message: `Message sent to ${chatId}`
            };
        } else {
            let detailedMessage = `Telegram API Error: ${data.description || 'Unknown error from Telegram API'}`;
            if (data.description && String(data.description).toLowerCase().includes("chat not found")) {
                detailedMessage = `Telegram API Error for Chat ID '${chatId}': ${data.description} (Hint: Ensure bot has access to this specific Chat ID. If it's a user ID, the user must have started the bot. If it's a group/channel ID, the bot must be a member/admin and the ID should typically be negative for groups/supergroups. Verify the bot is in the group/channel.)`;
            }
            return {
                success: false,
                message: detailedMessage,
                error: data
            };
        }
    } catch (error) {
        console.error('[TelegramLib] Error sending Telegram message via fetch:', error);
        return {
            success: false,
            message: `Network or parsing error: ${error.message}`,
            error
        };
    }
}
function escapeTelegramMarkdownV2(text) {
    if (text === null || text === undefined) return '';
    const textStr = String(text);
    const escapeChars = [
        '_',
        '*',
        '[',
        ']',
        '(',
        ')',
        '~',
        '`',
        '>',
        '#',
        '+',
        '-',
        '=',
        '|',
        '{',
        '}',
        '.',
        '!'
    ];
    return textStr.split('').map((char)=>escapeChars.includes(char) ? `\\${char}` : char).join('');
}
async function notifyAdminOnBalanceDeposit(userId, username, amountGh, reason) {
    console.log(`[TelegramLib LOG] Attempting notifyAdminOnBalanceDeposit for user: ${username} (ID: ${userId}), amount: ${amountGh}, reason: ${reason || 'N/A'}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token) {
        console.log("[TelegramLib LOG] notifyAdminOnBalanceDeposit: Admin bot token NOT configured.");
        return;
    }
    if (!telegramSettings.admin_bot_chat_ids) {
        console.log("[TelegramLib LOG] notifyAdminOnBalanceDeposit: Admin bot chat IDs NOT configured.");
        return;
    }
    if (!notificationPrefs?.notify_admin_on_balance_deposit) {
        console.log("[TelegramLib LOG] notifyAdminOnBalanceDeposit: Notification type is DISABLED in settings.");
        return;
    }
    console.log("[TelegramLib LOG] notifyAdminOnBalanceDeposit: Settings OK. Proceeding to send.");
    const reasonText = reason ? `\nПричина: \`${escapeTelegramMarkdownV2(reason)}\`` : '';
    const message = `💰 *Пополнение баланса*
Пользователь: \`${escapeTelegramMarkdownV2(username)}\` (ID: \`${userId}\`)
Сумма: \`+${escapeTelegramMarkdownV2(amountGh.toFixed(2))}\` GH${reasonText}`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib LOG] Sending balance deposit notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib LOG] Failed to send balance deposit notification to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib LOG] Balance deposit notification sent successfully to ${chatId}.`);
            }
        } catch (e) {
            console.error(`[TelegramLib LOG] CRITICAL ERROR sending balance deposit notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnProductPurchase(userId, username, productName, durationDays, amountGh) {
    console.log(`[TelegramLib LOG] Attempting notifyAdminOnProductPurchase for user: ${username}, product: ${productName}, amount: ${amountGh}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_product_purchase) {
        console.log("[TelegramLib LOG] notifyAdminOnProductPurchase: Check failed - Bot token, chat IDs, or setting disabled.");
        return;
    }
    console.log("[TelegramLib LOG] notifyAdminOnProductPurchase: Settings OK. Proceeding to send.");
    const durationText = durationDays ? ` (${escapeTelegramMarkdownV2(durationDays)} дн\\.)` : '';
    const message = `🛍️ *Новая покупка товара*
Пользователь: \`${escapeTelegramMarkdownV2(username)}\` (ID: \`${userId}\`)
Товар: \`${escapeTelegramMarkdownV2(productName)}\`${durationText}
Сумма: \`${escapeTelegramMarkdownV2(amountGh.toFixed(2))}\` GH`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib LOG] Sending product purchase notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib LOG] Failed to send product purchase notification to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib LOG] Product purchase notification sent successfully to ${chatId}.`);
            }
        } catch (e) {
            console.error(`[TelegramLib LOG] CRITICAL ERROR sending product purchase notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnPromoCodeCreation(adminUsername, promoCode) {
    console.log(`[TelegramLib LOG] Attempting notifyAdminOnPromoCodeCreation for code: ${promoCode.code}, created by: ${adminUsername || 'System'}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_promo_code_creation) {
        console.log("[TelegramLib LOG] notifyAdminOnPromoCodeCreation: Check failed - Bot token, chat IDs, or setting disabled.");
        return;
    }
    console.log("[TelegramLib LOG] notifyAdminOnPromoCodeCreation: Settings OK. Proceeding to send.");
    let rewardText = '';
    if (promoCode.type === 'balance_gh' && promoCode.value_gh) {
        rewardText = `Баланс: \`${escapeTelegramMarkdownV2(promoCode.value_gh.toFixed(2))}\` GH`;
    } else if (promoCode.type === 'product' && promoCode.product_name) {
        const duration = promoCode.duration_days ? ` (${escapeTelegramMarkdownV2(promoCode.duration_days)} дн\\.)` : '';
        const mode = promoCode.mode_label ? ` [${escapeTelegramMarkdownV2(promoCode.mode_label)}]` : '';
        rewardText = `Товар: \`${escapeTelegramMarkdownV2(promoCode.product_name)}\`${duration}${mode}`;
    }
    const message = `🎁 *Создан новый промокод*
Код: \`${escapeTelegramMarkdownV2(promoCode.code)}\`
Тип: \`${escapeTelegramMarkdownV2(promoCode.type)}\`
Награда: ${rewardText}
Макс\\. использований: \`${promoCode.max_uses}\`
Истекает: \`${promoCode.expires_at ? escapeTelegramMarkdownV2(new Date(promoCode.expires_at).toLocaleString('ru-RU')) : 'Бессрочно'}\`
${adminUsername ? `Создал: \`${escapeTelegramMarkdownV2(adminUsername)}\`` : 'Создан системой'}`;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib LOG] Sending promo code creation notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib LOG] Failed to send promo code creation notification to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib LOG] Promo code creation notification sent successfully to ${chatId}.`);
            }
        } catch (e) {
            console.error(`[TelegramLib LOG] CRITICAL ERROR sending promo code creation notification to ${chatId}:`, e);
        }
    }
}
async function notifyAdminOnAdminLogin(adminUsername, ipAddress) {
    console.log(`[TelegramLib LOG] Attempting notifyAdminOnAdminLogin for admin: ${adminUsername}, IP: ${ipAddress}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    if (!telegramSettings?.admin_bot_token || !telegramSettings.admin_bot_chat_ids || !notificationPrefs?.notify_admin_on_admin_login) {
        console.log("[TelegramLib LOG] notifyAdminOnAdminLogin: Check failed - Bot token, chat IDs, or setting disabled.");
        return;
    }
    console.log("[TelegramLib LOG] notifyAdminOnAdminLogin: Settings OK. Proceeding to send.");
    const ipText = ipAddress ? `IP: \`${escapeTelegramMarkdownV2(ipAddress)}\`` : 'IP не определен';
    const message = `🛡️ *Вход в Админ-панель*
Пользователь: \`${escapeTelegramMarkdownV2(adminUsername)}\`
${ipText}
Время: \`${escapeTelegramMarkdownV2(new Date().toLocaleString('ru-RU'))}\``;
    const chatIds = telegramSettings.admin_bot_chat_ids.split(',').map((id)=>id.trim()).filter((id)=>id);
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib LOG] Sending admin login notification to admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(telegramSettings.admin_bot_token, chatId, message);
            if (!result.success) {
                console.error(`[TelegramLib LOG] Failed to send admin login notification to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib LOG] Admin login notification sent successfully to ${chatId}.`);
            }
        } catch (e) {
            console.error(`[TelegramLib LOG] CRITICAL ERROR sending admin login notification to ${chatId}:`, e);
        }
    }
}
async function sendKeyActivationRequestToAdmin(item, user) {
    console.log(`[TelegramLib LOG] Attempting sendKeyActivationRequestToAdmin for item ID: ${item.id}, user: ${user.username}`);
    const { telegramSettings, notificationPrefs } = await getTelegramSettingsFromDb();
    const keyBotToken = telegramSettings?.key_bot_token;
    const adminChatIdsString = telegramSettings?.key_bot_admin_chat_ids;
    if (!keyBotToken) {
        const errorMsg = "[TelegramLib LOG] Key Bot token not configured in site_telegram_settings.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    if (!adminChatIdsString) {
        const errorMsg = "[TelegramLib LOG] Key Bot admin chat IDs not configured in site_telegram_settings.";
        console.error(errorMsg);
        return {
            success: false,
            message: errorMsg
        };
    }
    if (!notificationPrefs?.notify_admin_on_key_activation_request) {
        const logMsg = "[TelegramLib LOG] sendKeyActivationRequestToAdmin: Check failed - Notification type 'notify_admin_on_key_activation_request' is disabled.";
        console.log(logMsg);
        return {
            success: true,
            message: "Key activation request notification type disabled."
        };
    }
    console.log("[TelegramLib LOG] sendKeyActivationRequestToAdmin: Settings OK. Proceeding to send.");
    const productName = item.product_name || 'Неизвестный товар';
    const duration = item.duration_days ? ` (${item.duration_days} дн.)` : '';
    const mode = item.mode_label ? ` [${item.mode_label}]` : '';
    const userKey = item.activation_code || 'Ключ не указан';
    const message = `🔑 *Запрос на активацию ключа*
Пользователь: \`${escapeTelegramMarkdownV2(user.username)}\` (ID: \`${user.id}\`)
Товар: \`${escapeTelegramMarkdownV2(productName)}${escapeTelegramMarkdownV2(duration)}${escapeTelegramMarkdownV2(mode)}\`
Инвентарь ID: \`${item.id}\`
Предоставленный ключ: \`${escapeTelegramMarkdownV2(userKey)}\``;
    const inline_keyboard = [
        [
            {
                text: '✅ Активировать',
                callback_data: `activate_key:${item.id}`
            },
            {
                text: '❌ Отклонить',
                callback_data: `reject_key:${item.id}`
            }
        ]
    ];
    const chatIds = adminChatIdsString.split(',').map((id)=>id.trim()).filter((id)=>id);
    let allSentSuccessfully = true;
    let firstErrorResult = null;
    for (const chatId of chatIds){
        try {
            console.log(`[TelegramLib LOG] Sending key activation request to key bot admin chat ID: ${chatId}`);
            const result = await sendTelegramMessage(keyBotToken, chatId, message, 'MarkdownV2', {
                inline_keyboard
            });
            if (!result.success) {
                allSentSuccessfully = false;
                if (!firstErrorResult) {
                    firstErrorResult = result;
                }
                console.error(`[TelegramLib LOG] Failed to send key activation request to ${chatId}:`, result.message, result.error);
            } else {
                console.log(`[TelegramLib LOG] Key activation request sent successfully to ${chatId}.`);
            }
        } catch (e) {
            allSentSuccessfully = false;
            if (!firstErrorResult) {
                firstErrorResult = {
                    success: false,
                    message: `Network or parsing error for key activation: ${e.message}`,
                    error: e
                };
            }
            console.error(`[TelegramLib LOG] CRITICAL ERROR sending key activation request to ${chatId}:`, e);
        }
    }
    return allSentSuccessfully ? {
        success: true,
        message: "Уведомление администратору отправлено."
    } : firstErrorResult || {
        success: false,
        message: "Неизвестная ошибка при отправке уведомлений администратору."
    };
}
;
}}),
"[project]/src/app/api/admin/key-activation-requests/[inventoryItemId]/approve/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// src/app/api/admin/key-activation-requests/[inventoryItemId]/approve/route.ts
__turbopack_context__.s({
    "PUT": (()=>PUT)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/mysql.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/telegram.ts [app-route] (ecmascript)");
;
;
;
// import { sendEmail } from '@/lib/email'; // Placeholder for email notification
const SETTINGS_ROW_ID = 1;
async function getClientBotToken() {
    try {
        const settingsResults = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT client_bot_token FROM site_telegram_settings WHERE id = ? LIMIT 1', [
            SETTINGS_ROW_ID
        ]);
        if (settingsResults.length > 0 && settingsResults[0].client_bot_token) {
            return settingsResults[0].client_bot_token;
        }
        return null;
    } catch (error) {
        console.error("[ApproveKeyActivation] Error fetching client_bot_token:", error);
        return null;
    }
}
async function getNotificationSettings() {
    try {
        const results = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT * FROM site_notification_settings WHERE id = ? LIMIT 1', [
            SETTINGS_ROW_ID
        ]);
        if (results.length > 0) {
            const settings = results[0];
            return {
                id: settings.id,
                notify_on_registration: Boolean(settings.notify_on_registration),
                notify_on_balance_deposit: Boolean(settings.notify_on_balance_deposit),
                notify_on_product_purchase: Boolean(settings.notify_on_product_purchase),
                notify_on_support_reply: Boolean(settings.notify_on_support_reply),
                notify_on_software_activation: Boolean(settings.notify_on_software_activation),
                notify_on_license_expiry_soon: Boolean(settings.notify_on_license_expiry_soon),
                notify_on_promotions: Boolean(settings.notify_on_promotions),
                updated_at: settings.updated_at
            };
        }
        return null;
    } catch (error) {
        console.error("[ApproveKeyActivation] Error fetching site_notification_settings:", error);
        return null;
    }
}
async function PUT(request, { params }) {
    // TODO: Add admin authentication check
    const inventoryItemId = parseInt(params.inventoryItemId, 10);
    if (isNaN(inventoryItemId)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: 'Invalid inventory item ID'
        }, {
            status: 400
        });
    }
    try {
        const itemDetailsResults = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])(`SELECT 
         ui.*, 
         p.name as product_name_from_product_table,
         COALESCE(ppo.duration_days, cp.duration_days) as resolved_duration_days,
         ppo.mode_label as pricing_option_mode_label,
         u.id as user_db_id, u.username as user_db_username, u.email as user_email, u.telegram_id as user_telegram_id
       FROM user_inventory ui
       LEFT JOIN products p ON ui.related_product_id = p.id
       LEFT JOIN product_pricing_options ppo ON ui.product_pricing_option_id = ppo.id
       LEFT JOIN case_prizes cp ON ui.case_prize_id = cp.id
       LEFT JOIN users u ON ui.user_id = u.id
       WHERE ui.id = ?`, [
            inventoryItemId
        ]);
        if (itemDetailsResults.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: 'Предмет инвентаря не найден.'
            }, {
                status: 404
            });
        }
        const item = itemDetailsResults[0];
        item.product_name = item.product_name || item.product_name_from_product_table || 'Неизвестный продукт';
        item.duration_days = item.resolved_duration_days ? parseInt(item.resolved_duration_days, 10) : null;
        item.mode_label = item.pricing_option_mode_label || null;
        const activatedAt = new Date();
        let expiresAt = null;
        if (item.duration_days && item.duration_days > 0) {
            const expiryDate = new Date(activatedAt);
            expiryDate.setDate(expiryDate.getDate() + item.duration_days);
            expiresAt = expiryDate.toISOString().slice(0, 19).replace('T', ' ');
        }
        console.log(`Approving item ${inventoryItemId}. Duration: ${item.duration_days}, Calculated Expires At: ${expiresAt}`);
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('UPDATE user_inventory SET activation_status = ?, is_used = TRUE, activated_at = ?, expires_at = ?, updated_at = NOW() WHERE id = ? AND activation_status = ?', [
            'active',
            activatedAt.toISOString().slice(0, 19).replace('T', ' '),
            expiresAt,
            inventoryItemId,
            'pending_admin_approval'
        ]);
        if (result.affectedRows > 0) {
            const clientBotToken = await getClientBotToken();
            const notificationSettings = await getNotificationSettings();
            const userMessage = `Уважаемый пользователь, ваш ключ для "${item.product_name}"${item.duration_days ? ` на ${item.duration_days} дн.` : ''}${item.mode_label ? ` [${item.mode_label}]` : ''} был успешно активирован! Если вы не знаете как запустить софт, воспользуйтесь кнопкой "Как запускать?" в личном кабинете или напишите в техническую поддержку. Приятной игры!`;
            // Send Telegram notification to user if telegram_id and client_bot_token are available
            if (item.user_telegram_id && clientBotToken) {
                console.log(`[ApproveKeyActivation] Sending Telegram notification to user ${item.user_telegram_id}...`);
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$telegram$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendTelegramMessage"])(clientBotToken, item.user_telegram_id, userMessage, 'HTML');
            } else {
                console.log(`[ApproveKeyActivation] User ${item.user_telegram_id} Telegram ID or Client Bot Token not available. Skipping Telegram notification.`);
            }
            // Add to user_notifications table in the database
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('INSERT INTO user_notifications (user_id, message, link_url) VALUES (?, ?, ?)', [
                item.user_db_id,
                userMessage,
                '/account/inventory'
            ]);
            console.log(`[ApproveKeyActivation] Added notification to user_notifications for user ${item.user_db_id}.`);
            // Optional: Send email notification if enabled
            // if (notificationSettings?.notify_on_software_activation && item.user_email) {
            //   await sendEmail({
            //     to: item.user_email,
            //     subject: `Ваш ключ для ${item.product_name} активирован!`,
            //     text: userMessage,
            //     html: `<p>${userMessage.replace(/\n/g, "<br>")}</p>`
            //   });
            // }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: 'Запрос на активацию ключа успешно одобрен. Пользователь уведомлен.'
            });
        } else {
            const currentStatusResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$mysql$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["query"])('SELECT activation_status FROM user_inventory WHERE id = ?', [
                inventoryItemId
            ]);
            let currentStatus = 'unknown';
            if (currentStatusResult.length > 0) {
                currentStatus = currentStatusResult[0].activation_status;
            }
            if (currentStatus === 'active') {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    message: 'Запрос уже был одобрен ранее.'
                }, {
                    status: 200
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message: 'Запрос не найден в статусе ожидания или уже обработан.',
                current_status: currentStatus
            }, {
                status: 404
            });
        }
    } catch (error) {
        console.error(`API Admin Approve Key Activation (ID: ${inventoryItemId}) Error:`, error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            message: `Internal Server Error: ${error.message}`
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot%20of%20the%20server%5D__654cb720._.js.map